#the data
data= DF2
#variables names should be supplied explicitly
dv= "Pupil"
time= "Time"
id= "Subject"
trial= "Trial"
rotate= "promax" #oblique rotation
#append to the reduced dataframe
add= c("Set_size", "Color_type")
rf2 = reduce_rPCA(
data = DF2,
dv = dv,
time = time,
id = id,
trial = trial,
rotate= rotate,
add = add
)
be observed in an independent pool of data.
model= rf
DF2$Pupil[DF2$Trial==4 & DF2$Subject=="/tmp/tmpsub_9.edf.asc"]
vector=DF2$Pupil[DF2$Trial==4 & DF2$Subject=="/tmp/tmpsub_9.edf.asc"]
time= DF2$Time[DF2$Trial==4 & DF2$Subject=="/tmp/tmpsub_9.edf.asc"]
model$Loadings
rownames(model$Loadings)
as.numeric(rownames(model$Loadings))
as.numeric(rownames(rf2$Loadings))
trained_time= as.numeric(rownames(model$Loadings))
time[1]== trained_time[1]
time[1]== trained_time[1] +
length(time)== length(trained_time)
length(time)
length(trained_time)
tail(time, 1)== tail(trained_time, 1)
time[1]== trained_time[1]
tail(time, 1)== tail(trained_time, 1)
length(time)== length(trained_time)
mean(diff(time))== mean(diff(trained_time))
time[1]== trained_time[1] &
tail(time, 1)== tail(trained_time, 1) &
length(time)== length(trained_time) &
mean(diff(time))== mean(diff(trained_time))
! time[1]== trained_time[1] &
tail(time, 1)== tail(trained_time, 1) &
length(time)== length(trained_time) &
mean(diff(time))== mean(diff(trained_time))
rf$Scores[rf$Scores$trial==4 & rf$Scores$id=="/tmp/tmpsub_9.edf.asc",][,c("IC1", "IC2", "IC3")]
rf
rf$Scores[rf$Scores$trial==4 & rf$Scores$id=="/tmp/tmpsub_9.edf.asc",]
model$scaling
model$scaling$is_centered
model$scaling$is_scaled
vector_s= scale(vector,
center = ifelse(model$scaling$is_centered,
model$scaling$M, FALSE),
scale = ifelse(model$scaling$is_scaled
model$scaling$SD, FALSE))
vector_s= scale(vector,
center = ifelse(model$scaling$is_centered,
model$scaling$M, FALSE),
scale = ifelse(model$scaling$is_scaled,
model$scaling$SD, FALSE))
vector_s
all.equal(vector_s, vector)
vector
vector_s2= scale(vector,
center = ifelse(TRUE,
model$scaling$M, FALSE),
scale = ifelse(model$scaling$is_scaled,
model$scaling$SD, FALSE))
all.equal(vector_s, vector_s2)
View(cbind(vector_s. vector_s2))
View(cbind(vector_s, vector_s2))
(cor(vector_s, vector_s2))
vector_s2= scale(vector,
center = ifelse(FALSE,
model$scaling$M, FALSE),
scale = ifelse(TRUE,
model$scaling$SD, FALSE))
View(cbind(vector_s, vector_s2))
cor(vector_s, vector_s2)
names(model)
vector_s= scale(vector,
center = ifelse(model$scaling$is_centered,
model$scaling$M, FALSE),
scale = ifelse(model$scaling$is_scaled,
model$scaling$SD, FALSE))
model$ICA$Q
predict(model$PCA, vector_s)
t(vector_s)
predict(model$PCA, t(vector_s))
model$Loadings
model$Loadings %>% ncol()
predict(model$PCA, t(vector_s))[1:ncol(model$Loadings)]
model2= rf2
predict(model2$rPCAPCA, t(vector_s))[1:ncol(model$Loadings)]
predict(model2$rPCA, t(vector_s))[1:ncol(model$Loadings)]
predict(model2$rPCA, t(vector_s))
predict(model2$rPCA, (vector_s))
predict(model2$rPCA, data.frame(vector_s))
a= data.frame(vector_s)
a
a= data.frame(t(vector_s))
a
names(a)= rownames(model$Loadings)
predict(model2$rPCA, a)
predict(model2$rPCA, data = vector, old.data = model2$rs_mat)
rf2$Scores[rf2$Scores$trial==4 & rf2$Scores$id=="/tmp/tmpsub_9.edf.asc",]
rf3 = reduce_ICA(
data = DF2,
dv = dv,
time = time,
id = id,
trial = trial,
add = add
)
time= DF2$Time[DF2$Trial==4 & DF2$Subject=="/tmp/tmpsub_9.edf.asc"]
predict_feature(v1, time, rf3)
#' Predicts features' scores from a model
#'
#' Under development. This function is meant to predict
#' the scores of features obtained from a trained model
#' such as one returned by the 'reduce_*' family of functions.
#' In particular, the function would ideally work with any
#' technique implemented so far (PCA, rPCA, ICA) and whether or
#' not scaling and centering have been required.
#' This function could be used then within a more stringent
#' crossclassification approach (in which scores are computed)
#' anew, or even with different tasks to check whether different
#' signatures can be observed in an independent pool of data.
#' It takes as input a "time" argument to ensure the timepoints
#' used by the model to compute the loadings match, if
#' they don't the function returns an error.
#'
#' @param vector A vector variable to be transformed according
#' to the given model. Usually the pupil dimension for a trial/condition.
#' @param time A vector variable indicating the elapsed time. Should be the
#' same as the loadings' names in the model
#' @param model Object returned by 'reduce_*', e.g. 'reduce_PCA()'.
#' @return A numeric vector of scores - as many as the loadings in the model.
#'
#' @export
predict_feature= function(vector,
time,
model){
#checks here if time== rownames(Loadings)
trained_time= as.numeric(rownames(model$Loadings))
#initial time, last, length, average diff
if (! time[1]== trained_time[1] &
tail(time, 1)== tail(trained_time, 1) &
length(time)== length(trained_time) &
mean(diff(time))== mean(diff(trained_time))
) stop("Supplied and trained timepoints do not match")
#now scale if necessary
#scale appropriately
vector_s= scale(vector,
center = ifelse(model$scaling$is_centered,
model$scaling$M, FALSE),
scale = ifelse(model$scaling$is_scaled,
model$scaling$SD, FALSE))
#now predict
if("ICA" %in% names(model)){
new.data= as.matrix(t(vector_s))
Q = model$ICA$Q
Y = tcrossprod(new_data, Q)
res= Y %*% model$ICA$R
} else if("PCA" %in% names(model)) {
res= predict(model$PCA,
t(vector_s))[1:ncol(model$Loadings)]
} else {
res= predict(model$rPCA,
data = vector_s,
old.data = model$rs_mat)
}
return(res)
}
predict_feature(v1, time, rf3)
rf3 = reduce_ICA(
data = DF2,
dv = dv,
time = "Time",
id = id,
trial = trial,
add = add
)
rf3$Scores[rf3$Scores$trial==4 & rf3$Scores$id=="/tmp/tmpsub_9.edf.asc",]
predict_feature(v1, time, rf3)
v1= DF2$Pupil[DF2$Trial==4 & DF2$Subject=="/tmp/tmpsub_9.edf.asc"]
time= DF2$Time[DF2$Trial==4 & DF2$Subject=="/tmp/tmpsub_9.edf.asc"]
predict_feature(v1, time, rf3)
v1
time
model=rf3
trained_time= as.numeric(rownames(model$Loadings))
#initial time, last, length, average diff
if (! time[1]== trained_time[1] &
tail(time, 1)== tail(trained_time, 1) &
length(time)== length(trained_time) &
mean(diff(time))== mean(diff(trained_time))
) stop("Supplied and trained timepoints do not match")
vector_s= scale(vector,
center = ifelse(model$scaling$is_centered,
model$scaling$M, FALSE),
scale = ifelse(model$scaling$is_scaled,
model$scaling$SD, FALSE))
new.data= as.matrix(t(vector_s))
Q = model$ICA$Q
Y = tcrossprod(new_data, Q)
tcrossprod(new_data, Q)
#' Predicts features' scores from a model
#'
#' Under development. This function is meant to predict
#' the scores of features obtained from a trained model
#' such as one returned by the 'reduce_*' family of functions.
#' In particular, the function would ideally work with any
#' technique implemented so far (PCA, rPCA, ICA) and whether or
#' not scaling and centering have been required.
#' This function could be used then within a more stringent
#' crossclassification approach (in which scores are computed)
#' anew, or even with different tasks to check whether different
#' signatures can be observed in an independent pool of data.
#' It takes as input a "time" argument to ensure the timepoints
#' used by the model to compute the loadings match, if
#' they don't the function returns an error.
#'
#' @param vector A vector variable to be transformed according
#' to the given model. Usually the pupil dimension for a trial/condition.
#' @param time A vector variable indicating the elapsed time. Should be the
#' same as the loadings' names in the model
#' @param model Object returned by 'reduce_*', e.g. 'reduce_PCA()'.
#' @return A numeric vector of scores - as many as the loadings in the model.
#'
#' @export
predict_feature= function(vector,
time,
model){
#checks here if time== rownames(Loadings)
trained_time= as.numeric(rownames(model$Loadings))
#initial time, last, length, average diff
if (! time[1]== trained_time[1] &
tail(time, 1)== tail(trained_time, 1) &
length(time)== length(trained_time) &
mean(diff(time))== mean(diff(trained_time))
) stop("Supplied and trained timepoints do not match")
#now scale if necessary
#scale appropriately
vector_s= scale(vector,
center = ifelse(model$scaling$is_centered,
model$scaling$M, FALSE),
scale = ifelse(model$scaling$is_scaled,
model$scaling$SD, FALSE))
#now predict
if("ICA" %in% names(model)){
new_data= as.matrix(t(vector_s))
Q = model$ICA$Q
Y = tcrossprod(new_data, Q)
res= Y %*% model$ICA$R
} else if("PCA" %in% names(model)) {
res= predict(model$PCA,
t(vector_s))[1:ncol(model$Loadings)]
} else {
res= predict(model$rPCA,
data = vector_s,
old.data = model$rs_mat)
}
return(res)
}
#' Predicts features' scores from a model
#'
#' Under development. This function is meant to predict
#' the scores of features obtained from a trained model
#' such as one returned by the 'reduce_*' family of functions.
#' In particular, the function would ideally work with any
#' technique implemented so far (PCA, rPCA, ICA) and whether or
#' not scaling and centering have been required.
#' This function could be used then within a more stringent
#' crossclassification approach (in which scores are computed)
#' anew, or even with different tasks to check whether different
#' signatures can be observed in an independent pool of data.
#' It takes as input a "time" argument to ensure the timepoints
#' used by the model to compute the loadings match, if
#' they don't the function returns an error.
#'
#' @param vector A vector variable to be transformed according
#' to the given model. Usually the pupil dimension for a trial/condition.
#' @param time A vector variable indicating the elapsed time. Should be the
#' same as the loadings' names in the model
#' @param model Object returned by 'reduce_*', e.g. 'reduce_PCA()'.
#' @return A numeric vector of scores - as many as the loadings in the model.
#'
#' @export
predict_feature= function(vector,
time,
model){
#checks here if time== rownames(Loadings)
trained_time= as.numeric(rownames(model$Loadings))
#initial time, last, length, average diff
if (! time[1]== trained_time[1] &
tail(time, 1)== tail(trained_time, 1) &
length(time)== length(trained_time) &
mean(diff(time))== mean(diff(trained_time))
) stop("Supplied and trained timepoints do not match")
#now scale if necessary
#scale appropriately
vector_s= scale(vector,
center = ifelse(model$scaling$is_centered,
model$scaling$M, FALSE),
scale = ifelse(model$scaling$is_scaled,
model$scaling$SD, FALSE))
#now predict
if("ICA" %in% names(model)){
new_data= as.matrix(t(vector_s))
Q = model$ICA$Q
Y = tcrossprod(new_data, Q)
res= Y %*% model$ICA$R
} else if("PCA" %in% names(model)) {
res= predict(model$PCA,
t(vector_s))[1:ncol(model$Loadings)]
} else {
res= predict(model$rPCA,
data = vector_s,
old.data = model$rs_mat)
}
return(res)
}
new_data= as.matrix(t(vector_s))
Q = model$ICA$Q
Y = tcrossprod(new_data, Q)
res= Y %*% model$ICA$R
predict_feature(v1, time, model=rf3)
rf3$Scores[rf3$Scores$trial==4 & rf3$Scores$id=="/tmp/tmpsub_9.edf.asc",]
rf$Scores[rf$Scores$trial==4 & rf$Scores$id=="/tmp/tmpsub_9.edf.asc",]
predict_feature(v1, time, rf)
rf2$Scores[rf2$Scores$trial==4 & rf2$Scores$id=="/tmp/tmpsub_9.edf.asc",]
predict_feature(v1, time, rf2)
#the data
data= DF2
#variables names should be supplied explicitly
dv= "Pupil"
time= "Time"
id= "Subject"
trial= "Trial"
#append to the reduced dataframe
add= c("Set_size", "Color_type")
rf = reduce_PCA(
data = DF2,
dv = dv,
time = time,
id = id,center = T, scale = T,
trial = trial,
add = add
)
rf$Scores[rf$Scores$trial==4 & rf$Scores$id=="/tmp/tmpsub_9.edf.asc",]
predict_feature(v1, time, rf)
time= DF2$Time[DF2$Trial==4 & DF2$Subject=="/tmp/tmpsub_9.edf.asc"]
predict_feature(v1, time, rf)
#the data
data= DF2
#variables names should be supplied explicitly
dv= "Pupil"
time= "Time"
id= "Subject"
trial= "Trial"
rotate= "promax" #oblique rotation
#append to the reduced dataframe
add= c("Set_size", "Color_type")
rf2 = reduce_rPCA(
data = DF2,
dv = dv,
time = time,
id = id,
trial = trial,
rotate= rotate,
add = add
)
#the data
data= DF2
#variables names should be supplied explicitly
dv= "Pupil"
time= "Time"
id= "Subject"
trial= "Trial"
rotate= "promax" #oblique rotation
#append to the reduced dataframe
add= c("Set_size", "Color_type")
rf2 = reduce_rPCA(
data = DF2,
dv = dv,
time = time,
id = id,
trial = trial,
rotate= rotate,
add = add, center = T, scale= T
)
v1= DF2$Pupil[DF2$Trial==4 & DF2$Subject=="/tmp/tmpsub_9.edf.asc"]
time= DF2$Time[DF2$Trial==4 & DF2$Subject=="/tmp/tmpsub_9.edf.asc"]
rf2$Scores[rf2$Scores$trial==4 & rf2$Scores$id=="/tmp/tmpsub_9.edf.asc",]
predict_feature(v1, time, rf2)
rf$Scores[rf$Scores$trial==4 & rf$Scores$id=="/tmp/tmpsub_9.edf.asc",]
predict_feature(v1, time, rf)
predict_feature(v1, time, model=rf3)
rf3$Scores[rf3$Scores$trial==4 & rf3$Scores$id=="/tmp/tmpsub_9.edf.asc",]
predict_feature(v1, time, rf2)
rf2$Scores[rf2$Scores$trial==4 & rf2$Scores$id=="/tmp/tmpsub_9.edf.asc",]
rf2$Scores[rf2$Scores$trial==4 & rf2$Scores$id=="/tmp/tmpsub_9.edf.asc",]
predict_feature(v1, time, rf2)
rf$Scores[rf$Scores$trial==4 & rf$Scores$id=="/tmp/tmpsub_9.edf.asc",]
predict_feature(v1, time, rf)
#the data
data= DF2
#variables names should be supplied explicitly
dv= "Pupil"
time= "Time"
id= "Subject"
trial= "Trial"
#append to the reduced dataframe
add= c("Set_size", "Color_type")
rf = reduce_PCA(
data = DF2,
dv = dv,
time = time,
id = id, center = T, scale = T,
trial = trial,
add = add
)
v1= DF2$Pupil[DF2$Trial==4 & DF2$Subject=="/tmp/tmpsub_9.edf.asc"]
time= DF2$Time[DF2$Trial==4 & DF2$Subject=="/tmp/tmpsub_9.edf.asc"]
rf$Scores[rf$Scores$trial==4 & rf$Scores$id=="/tmp/tmpsub_9.edf.asc",]
predict_feature(v1, time, rf)
vector_s
model$scaling$SD
vector_s * model$scaling$SD
vector_s
vector_s / model$scaling$SD
#' Predicts features' scores from a model
#'
#' Under development. This function is meant to predict
#' the scores of features obtained from a trained model
#' such as one returned by the 'reduce_*' family of functions.
#' In particular, the function would ideally work with any
#' technique implemented so far (PCA, rPCA, ICA) and whether or
#' not scaling and centering have been required.
#' This function could be used then within a more stringent
#' crossclassification approach (in which scores are computed)
#' anew, or even with different tasks to check whether different
#' signatures can be observed in an independent pool of data.
#' It takes as input a "time" argument to ensure the timepoints
#' used by the model to compute the loadings match, if
#' they don't the function returns an error.
#'
#' @param vector A vector variable to be transformed according
#' to the given model. Usually the pupil dimension for a trial/condition.
#' @param time A vector variable indicating the elapsed time. Should be the
#' same as the loadings' names in the model
#' @param model Object returned by 'reduce_*', e.g. 'reduce_PCA()'.
#' @return A numeric vector of scores - as many as the loadings in the model.
#'
#' @export
predict_feature= function(vector,
time,
model){
#checks here if time== rownames(Loadings)
trained_time= as.numeric(rownames(model$Loadings))
#initial time, last, length, average diff
if (! time[1]== trained_time[1] &
tail(time, 1)== tail(trained_time, 1) &
length(time)== length(trained_time) &
mean(diff(time))== mean(diff(trained_time))
) stop("Supplied and trained timepoints do not match")
#now scale if necessary
#scale appropriately
vector_s= vector
if(model$scaling$is_centered){
vector_s= vector_s - model$scaling$M
}
if(model$scaling$is_scaled){
vector_s= vector_s / model$scaling$SD
}
# vector_s= scale(vector,
#               center = ifelse(model$scaling$is_centered,
#                               model$scaling$M, FALSE),
#               scale = ifelse(model$scaling$is_scaled,
#                              model$scaling$SD, FALSE))
#now predict
if("ICA" %in% names(model)){
new_data= as.matrix(t(vector_s))
Q = model$ICA$Q
Y = tcrossprod(new_data, Q)
res= Y %*% model$ICA$R
} else if("PCA" %in% names(model)) {
res= predict(model$PCA,
t(vector_s))[1:ncol(model$Loadings)]
} else {
res= predict(model$rPCA,
data = vector_s,
old.data = model$rs_mat)
}
return(res)
}
rf$Scores[rf$Scores$trial==4 & rf$Scores$id=="/tmp/tmpsub_9.edf.asc",]
predict_feature(v1, time, rf)
rf2$Scores[rf2$Scores$trial==4 & rf2$Scores$id=="/tmp/tmpsub_9.edf.asc",]
predict_feature(v1, time, rf2)
predict_feature(v1, time, model=rf3)
rf3$Scores[rf3$Scores$trial==4 & rf3$Scores$id=="/tmp/tmpsub_9.edf.asc",]
gc()
library(Pupilla)
Pupilla::predict_feature()
Pupilla::predict_feature
library("pkgdown")
clean_site()
