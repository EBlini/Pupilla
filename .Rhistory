x= c(1:10, NA, 2, NA, 1:10)
clean_island(x)
clean_island(x, 1)
x= c(1:10, NA, 2, 2, NA, 1:10)
clean_island(x, 1)
clean_island(x, 2)
clean_island(x, 3)
x= c(1:10, NA, 2, 2,2, NA, 1:10)
clean_island(x, 3)
rle2 <- function (x)  {
stopifnot("'x' must be a vector of an atomic type" = is.atomic(x))
n <- length(x)
if (n == 0L) {
return(structure(list(
lengths = integer(), values = x)
), class = 'rle')
}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Where does next value not equal current value?
# i.e. y will be TRUE at the last index before a change
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
y <- (x[-1L] != x[-n])
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Since NAs are never equal to anything, NAs in 'x' will lead to NAs in 'y'.
# These current NAs in 'y' tell use nothing - Set all NAs in y to FALSE
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
y[is.na(y)] <- FALSE
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# When a value in x is NA and its successor is not (or vice versa) then that
# should also count as a value change and location in 'y' should be set to TRUE
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
y <- y | xor(is.na(x[-1L]), is.na(x[-n]))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Any TRUE locations in 'y' are the end of a run, where the next value
# changes to something different
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
i <- c(which(y), n)
structure(list(
lengths = diff(c(0L, i)),
values  = x[i]
), class = 'rle')
}
rle2(x)
rl = rle2(x)
as.data.frame(cbind(rl$lengths, rl$values))
rd = as.data.frame(cbind(rl$lengths, rl$values))
dplyr::slice(rd, which(is.na(rl$values)))
rdna = dplyr::slice(rd, which(is.na(rl$values)))
max(rdna[, 1])
length(vec)
x= c(1:10, NA, 2, 2,2, NA, 1:10)
x= clean_island(x, 3)
rl = rle2(x)
rl
rd = as.data.frame(cbind(rl$lengths, rl$values))
rd
x
rd
rdna = dplyr::slice(rd, which(is.na(rl$values)))
rdna
rownames(is.na(rd$V2))
rd$cs= cumsum(rd$V1)
rd
length(x)
rdna = dplyr::slice(rd, which(is.na(rl$values)))
rdna
rdna
eb= 1:nrow(rdna)
eb
rdna$from[eb]
rdna
x= c(1:10, NA, 2, 2,2, NA, 1:10)
x= clean_island(x, 3)
#extend blink
extend_blink= 3
rl = rle2(x)
rd = as.data.frame(cbind(rl$lengths, rl$values))
rd$from= cumsum(rd$V1)
rdna = dplyr::slice(rd, which(is.na(rl$values)))
eb= 1:nrow(rdna)
rdna$from[eb]
x
rdna$to[eb]
rdna
x= c(1:10, NA, 2, 2,2, NA, 1:10)
x= clean_island(x, 3)
#extend blink
extend_blink= 3
rl = rle2(x)
rd = as.data.frame(cbind(rl$lengths, rl$values))
rd$to= cumsum(rd$V1)
rdna = dplyr::slice(rd, which(is.na(rl$values)))
rdna
rdna$to[eb]
extend_blink
rdna$V1[eb]
rdna$V1[eb]
rdna$to[eb]
from= rdna$to[eb] - (rdna$V1[eb]-1) - extend_blink
to= rdna$to[eb] + extend_blink
to
from
x= c(1:10, NA, 2, 2,2, NA, 1:10)
x= clean_island(x, 3)
#extend blink
extend_blink= 3
rl = rle2(x)
rd = as.data.frame(cbind(rl$lengths, rl$values))
rd$to= cumsum(rd$V1)
rdna = dplyr::slice(rd, which(is.na(rl$values)))
#remove blinks
eb= 1:nrow(rdna)
for(i in eb) {
from= rdna$to[eb] - (rdna$V1[eb]-1) - extend_blink
to= rdna$to[eb] + extend_blink
if(from < 1)(from= 1)
if(to>length(x))(to= length(x))
x[from:to]= NA
}
x
vector=x
rl = rle2(vector)
rd = as.data.frame(cbind(rl$lengths, rl$values))
rd$to= cumsum(rd$V1)
rdna = dplyr::slice(rd, which(is.na(rl$values)))
rdna
ext_blink= function(vector, extend_blink){
rl = rle2(vector)
rd = as.data.frame(cbind(rl$lengths, rl$values))
rd$to= cumsum(rd$V1)
rdna = dplyr::slice(rd, which(is.na(rl$values)))
#remove blinks
eb= 1:nrow(rdna)
for(i in eb) {
from= rdna$to[eb] - (rdna$V1[eb]-1) - extend_blink
to= rdna$to[eb] + extend_blink
if(from < 1)(from= 1)
if(to>length(vector))(to= length(vector))
vector[from:to]= NA
}
return(vector)
}
x= c(1:10, NA, 2, 2,2, NA, 1:10)
x= clean_island(x, 3)
ext_blink(x, 3)
x= c(1:10, NA, 2, 2,2, NA, 1:10)
x= c(1:10, NA, 2, 2,2, NA, 1:10)
ext_blink(x, 1)
extend_blink=1
vector=x
rl = rle2(vector)
rd = as.data.frame(cbind(rl$lengths, rl$values))
rd$to= cumsum(rd$V1)
rl
rd
rdna = dplyr::slice(rd, which(is.na(rl$values)))
rdna
rdna
eb= 1:nrow(rdna)
eb
i=1
from= rdna$to[eb] - (rdna$V1[eb]-1) - extend_blink
to= rdna$to[eb] + extend_blink
if(from < 1)(from= 1)
if(to>length(vector))(to= length(vector))
from
for(i in eb) {
from= rdna$to[i] - (rdna$V1[i]-1) - extend_blink
to= rdna$to[i] + extend_blink
if(from < 1)(from= 1)
if(to>length(vector))(to= length(vector))
vector[from:to]= NA
}
vector
ext_blink= function(vector, extend_blink){
rl = rle2(vector)
rd = as.data.frame(cbind(rl$lengths, rl$values))
rd$to= cumsum(rd$V1)
rdna = dplyr::slice(rd, which(is.na(rl$values)))
#remove blinks
eb= 1:nrow(rdna)
for(i in eb) {
from= rdna$to[i] - (rdna$V1[i]-1) - extend_blink
to= rdna$to[i] + extend_blink
if(from < 1)(from= 1)
if(to>length(vector))(to= length(vector))
vector[from:to]= NA
}
return(vector)
}
x= c(1:10, NA, 2, 2,2, NA, 1:10)
x= clean_island(x, 3)
ext_blink(x, 3)
x= c(1:10, NA, 2, 2,2, NA, 1:10)
ext_blink(x, 1)
#from: https://coolbutuseless.github.io/2020/08/26/run-length-encoding-and-the-problem-of-nas/
rle2 <- function (x)  {
stopifnot("'x' must be a vector of an atomic type" = is.atomic(x))
n <- length(x)
if (n == 0L) {
return(structure(list(
lengths = integer(), values = x)
), class = 'rle')
}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Where does next value not equal current value?
# i.e. y will be TRUE at the last index before a change
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
y <- (x[-1L] != x[-n])
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Since NAs are never equal to anything, NAs in 'x' will lead to NAs in 'y'.
# These current NAs in 'y' tell use nothing - Set all NAs in y to FALSE
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
y[is.na(y)] <- FALSE
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# When a value in x is NA and its successor is not (or vice versa) then that
# should also count as a value change and location in 'y' should be set to TRUE
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
y <- y | xor(is.na(x[-1L]), is.na(x[-n]))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Any TRUE locations in 'y' are the end of a run, where the next value
# changes to something different
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
i <- c(which(y), n)
structure(list(
lengths = diff(c(0L, i)),
values  = x[i]
), class = 'rle')
}
# check continuous NA in a passed vector, according to a % threshold
check_cont_na <- function(vec, thresh){
rl = rle2(vec)
rd = as.data.frame(cbind(rl$lengths, rl$values))
rdna = dplyr::slice(rd, which(is.na(rl$values)))
if (max(rdna[, 1]) / length(vec) > thresh)(FALSE) else (TRUE)
}
# x= c(1:10, NA, NA)
# check_cont_na(x, 0.16)
ext_blink= function(vector, extend_blink){
rl = rle2(vector)
rd = as.data.frame(cbind(rl$lengths, rl$values))
rd$to= cumsum(rd$V1)
rdna = dplyr::slice(rd, which(is.na(rl$values)))
#remove blinks
eb= 1:nrow(rdna)
for(i in eb) {
from= rdna$to[i] - (rdna$V1[i]-1) - extend_blink
to= rdna$to[i] + extend_blink
if(from < 1)(from= 1)
if(to>length(vector))(to= length(vector))
vector[from:to]= NA
}
return(vector)
}
# x= c(1:10, NA, 2, 2,2, NA, 1:10)
# x= clean_island(x, 3)
# ext_blink(x, 3)
#
# x= c(1:10, NA, 2, 2,2, NA, 1:10)
# ext_blink(x, 1)
#' Linearly interpolate signal provided quality checks are met, else only returns NAs
#'
#' This is used to linearly interpolate any data provided successful quality controls.
#' If these controls are not met, the returned vector is a vector of equal length
#' composed of only NAs. Quality checks are general (i.e., overall percentage of
#' available non NA data) or relative to consecutive gaps in the signal, which
#' must not exceed a given threshold. Thresholds refer to the
#' maximum rate (percentage) of entries that are allowed to be NAs; results
#' are only interpolated below these thresholds.
#'
#' @param vector A vector to interpolate.
#' @param extend_blink NAs are extended by these many samples
#' prior to interpolation. This gets rid of signal that may be compromised
#' in the close proximity of a blink.
#' @param overall_thresh Overall quality threshold: e.g., the total amount of data
#' that is allowed to be missing from the original vector.
#' @param consecutive_thresh Consecutive gaps in the signal: e.g., the total amount of data
#' that is allowed to be missing from the original vector **consecutively**.
#' @return A numeric vector of interpolated data or NAs if quality checks are not met.
#'
#' @export
interpolate= function(vector,
extend_blink= pp_options("extend_blink"),
overall_thresh= pp_options("overall_thresh"),
consecutive_thresh= pp_options("consecutive_thresh")){
#first extend blinks if required (then check criteria)
if(!is.null(vector)){
vector= ext_blink(vector, extend_blink)
}
#now check criteria
#TRUE if quality is met
criterion= sum(is.na(vector))/length(vector)< overall_thresh
if(!is.null(consecutive_thresh)) {
#also TRUE if quality is met
criterion= criterion * check_cont_na(vector, consecutive_thresh)
}
#if failed, return NAs, else...
if(criterion== 0)(return(rep(NA, length(vector)))) else {
#if the first sample is NA, interpolation is not possible
#set this value to first non-NA value
if (is.na(vector[1])){
vector[1]= na.omit(vector)[1]
}
#same for last observation
if (is.na(vector[length(vector)])){
vector[length(vector)]= tail(na.omit(vector), 1)
}
#interpolate linearly
vector= zoo::na.approx(vector)
return(vector)
} #end criterion met
}
x= c(1:10, NA, NA, 8)
interpolate(x, 2, 0.1)
interpolate(x, 2, 0.1)
interpolate(x, 2,  0.1, 0.1)
interpolate(x, 2, 0.5, 0.1)
interpolate(x, 2, 0.5, 0.4)
x= c(1:10, NA, NA, 8)
ext_blink(x, 2)
interpolate(x, 2, 0.5, 0.4)
devtools::document()
devtools::document()
devtools::build_site()
gc()
devtools::document()
devtools::build_site()
devtools::install()
devtools::install()
install.packages("cli")
install.packages("cli")
install.packages("cli")
install.packages("purrr")
devtools::install()
devtools::document()
devtools::document()
devtools::build_site()
library("dplyr")
library("ggplot2")
library("Pupilla")
wd= "G:\\Il mio Drive\\pupil NRS\\DotProbeTask\\02 PV\\02 data"
subject= 1:51
#groups
group= c("NS", "S", "NS", "NS", "S","S", "NS", "S",
"S", "S", "S", "S", "S", "S", "NS", "S",
"NS", "S", "NS", "S", "NS", "NS", "S", "NS",
"S", "NS", "NS", "NS", "NS", "NS", "NS", "S",
"S", "S", "S", "NS", "NS", "NS", "NS", "S",
"NS", "NS", "NS", "S", "S", "S", "S", "S",
"S", "S", "S")
data= read_TOBII(subject, wd)
ET= data$ET
BD= data$BD
ET$Event= ifelse(ET$Event== "", NA, ET$Event)
ET= tidyr::fill(ET, Event, .direction = "down")
ET= ET %>%
group_by(p_ID) %>%
mutate(Trial= detect_change(Event, key= "scrambled"))
table(ET$Trial)
table(BD$Trial)
ET= ET[ET$Trial>=0,]
#whether it's practice or experiment
ET$Phase= copy_variable("Phase")
table(ET$Phase, ET$Trial)
#discard practice
ET= ET[ET$Phase== "experiment",]
BD= BD[BD$Phase== "experiment",]
ET$Trial= copy_variable("Trial")
range(ET$Trial)
range(BD$Trial)
ET$Condition= copy_variable("Condition")
ET$Cue= copy_variable("Cue")
ET$Accuracy= copy_variable("Accuracy")
ET$Image= copy_variable("Image")
ET$RT = as.numeric(copy_variable("RT"))
ET$Pupil= consolidate_signal(ET$PupilSizeLeft, ET$PupilSizeRight,
ET$PupilValidityLeft, ET$PupilValidityRight,
strategy = "conservative",
plausible= c(2, 7))
ET$Pupil
ET= ET[ET$Event %in% c("scrambled", "target"),]
ET= ET %>%
group_by(p_ID, Trial) %>%
mutate(Time= c(0,
cumsum(diff(TimeStamp))))
summary(ET$Time)
ET= ET %>%
group_by(p_ID, Trial) %>%
mutate(Anomaly= ifelse(max(Time)>4500, 1, 0))
table(ET$p_ID[ET$Anomaly== 1], ET$Trial[ET$Anomaly== 1]) #for 2 participants, the trial around the break...
ET= ET[ET$Anomaly== 0,]
#realign Time according to start of the target
ET= ET %>%
group_by(p_ID, Trial) %>%
mutate(Time= Time - Time[Event== "target"][1])
summary(ET$Time)
sum(ET$Time >-1000 & ET$Time<3000)/nrow(ET)
ET= ET[ET$Time >-1000 & ET$Time<3000,]
#filter subjs here and add group
ET= ET %>% filter(!p_ID %in% c(2, 9, 10, 13, 25, 29, 30, 34, 38, 48, 49))
# group= group[-c(2, 9, 10, 13, 25, 29, 30, 34, 38,48, 49)]
# table(group)
ET$Group= group[ET$p_ID]
pp_options()
#entire preprocessing
ET= ET %>%
group_by(p_ID, Trial) %>%
mutate(Pupil_pp= pre_process(Pupil, Time))
#drop
ET= ET %>% filter(!is.na(Pupil_pp))
#downsample
ET$Time= downsample_time(ET$Time, 25)
summary(ET$Time)
ET= ET %>%
group_by(p_ID, Group, Condition, Image, Trial, Time) %>%
summarise(Pupil= median(Pupil_pp, na.rm = T))
colnames(ET)[1]= "Subject"
####raw signals
{ET %>%
group_by(Subject, Group, Time) %>%
summarise(Pupil= mean(Pupil)) %>%
mutate(Subject= as.factor(Subject)) %>%
ggplot(aes(x= Time, y= Pupil)) +
geom_line(aes(color= Subject),
size= 1, show.legend = F) +
facet_wrap("Group")
ET %>%
group_by(Subject, Group, Time) %>%
summarise(Pupil= mean(Pupil)) %>%
group_by(Group, Time) %>%
summarise(M_Pupil= mean(Pupil),
SEM_Pupil= sd(Pupil)/sqrt(n())) %>%
ggplot(aes(x= Time, y= M_Pupil, color= Group)) +
geom_errorbar(aes(ymin= M_Pupil-SEM_Pupil,
ymax= M_Pupil+SEM_Pupil),
alpha= 0.5) +
geom_line(size= 1)
ET %>%
group_by(Subject, Group, Time, Condition) %>%
summarise(Pupil= mean(Pupil)) %>%
group_by(Group, Time, Condition) %>%
summarise(M_Pupil= mean(Pupil),
SEM_Pupil= sd(Pupil)/sqrt(n())) %>%
ggplot(aes(x= Time, y= M_Pupil,
color= Group, linetype= Condition)) +
geom_line(size= 1)
}
ET= ET %>%
group_by(Subject) %>%
mutate(Pupil= (Pupil-mean(na.omit(Pupil)))/sd(na.omit(Pupil)))
ET= ET %>%
group_by(Subject, Trial) %>%
mutate(Pupil= Pupil - Pupil[Time== 0][1])
summary(ET$Pupil)
ET$Subject= as.factor(ET$Subject)
ET$Condition= ifelse(ET$Condition== "A",
"Nicotine-related",
"Control")
ET$Group= ifelse(ET$Group== "S",
"Smokers",
"Non smokers")
pupil= ET %>%
group_by(Subject, Group, Time, Condition) %>%
summarise(Pupil= mean(Pupil, na.rm=T))
pupil_group= pupil %>%
group_by(Group, Time, Condition) %>%
summarise(Pupil= mean(Pupil, na.rm=T))
commonTheme= list(theme_bw(),
theme(text= element_text(size= 16,
face="bold")),
geom_hline(yintercept = 0, color= "black"),
geom_vline(xintercept = 0, color= "black"),
xlab("Time (ms)"),
ylab("Pupil dilation (z scores)"))
p1=
pupil_group %>%
#filter(Time>=0) %>%
ggplot(aes(x= Time, y= Pupil,
color= Group, linetype= Condition)) +
commonTheme +
geom_line(size= 1)
p1
pupil_diff= ET %>%
group_by(Subject, Group, Time, Condition) %>%
summarise(Pupil= mean(Pupil, na.rm= T)) %>%
group_by(Subject, Group, Time) %>%
summarise(Pupil= Pupil[Condition== "Nicotine-related"] - Pupil[Condition== "Control"])
pupil_diff_group= pupil_diff %>%
group_by(Group, Time) %>%
summarise(SEM= sd(Pupil)/sqrt(length(Pupil)),
N= length(Pupil),
Pupil= mean(Pupil)) %>%
mutate(ci.min= Pupil - 1.96 * SEM,
ci.max= Pupil + 1.96 * SEM)
p2= pupil_diff_group %>%
ggplot(aes(x= Time, y= Pupil, color= Group)) +
commonTheme +
geom_ribbon(aes(ymin= ci.min,
ymax= ci.max,
fill= Group),
alpha= 0.3, color= NA) +
geom_line(size= 1.2, show.legend = F) +
ylab("Pupil dilation by NRS") + guides(NULL)
p2
test= pupil_diff %>%
group_by(Time) %>%
summarise(p= t.test(Pupil[Group== "Smokers"],
Pupil[Group== "Non smokers"])$p.value)
plot(test$p ~ unique(pupil_diff$Time))
segments(x0= -975, x1= 2975, y0 = 0.05, y1 = 0.05)
segments(x0= 0, x1= 0, y0 = 0, y1 = 1)
pkgdown::build_site()
