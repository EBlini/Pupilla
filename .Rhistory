alpha = .3, fill = "light blue") +
geom_vline(xintercept = c(0, 3000),
linewidth= 1,
color= "gray", linetype= "dashed") +
geom_hline(yintercept = 0, linewidth= 1,
color= "gray", linetype= "dashed") +
geom_line(aes(color= Cue),
linewidth= 1.2) + xlim(c(-750, 8000)) +
geom_ribbon(aes(ymin= Pupil-SEM,
ymax= Pupil+SEM),
alpha= 0.5, color= NA) +
ggtitle("Second part ") + commonTheme
ET %>%
#isola fase
filter(Event %in% c("fixation", "post_resp_fix", "Wait_Feedback", "feedback")) %>%
# #riparti da zero con il tempo
# group_by(Subject, trial) %>%
# mutate(Time= c(0, cumsum(diff(Time)))) %>%
#riallinea tempo
group_by(Subject, trial) %>%
mutate(Time= Time - Time[Event== "Wait_Feedback"][1]) %>%
#sottrai baseline
group_by(Subject, Cue, trial) %>%
mutate(Pupil= Pupil - mean(Pupil[Event== "fixation"])) %>%
filter(Event %in% c("post_resp_fix", "Wait_Feedback", "feedback")) %>%
group_by(Subject, Cue, Time) %>%
summarise(SEM= sd(Pupil)/n(),
Pupil= mean(Pupil)) %>%
#additional filter to clean some final mess
filter(Time < 5995) %>%
ggplot(aes(x= Time, y= Pupil, fill= Cue)) +
annotate("rect",
xmin = c(0, 3000),
xmax = c(750, 3750),
ymin = c(-Inf), ymax = c(Inf),
alpha = .3, fill = "light blue") +
geom_vline(xintercept = c(0, 3000),
linewidth= 1,
color= "gray", linetype= "dashed") +
geom_hline(yintercept = 0, linewidth= 1,
color= "gray", linetype= "dashed") +
geom_line(aes(color= Cue),
linewidth= 1.2) + xlim(c(-750, 8000)) +
geom_ribbon(aes(ymin= Pupil-SEM,
ymax= Pupil+SEM),
alpha= 0.5, color= NA) +
ggtitle("Second part - same baseline") + commonTheme
ggsave(paste0("plots//Second part - same baseline", subj, ".jpg"), width = 6, height = 6)
file.choose()
install.packages("readxl")
data= readxl::read_xlsx(file)
file
file= "I:\\Il mio Drive\\Esercitazioni\\Corsi aggiuntivi solo cognitiva.xlsx"
data= readxl::read_xlsx(file)
choose.dir()
dir= "I:\\Il mio Drive\\Esercitazioni"
name= "\\converted.txt"
write.table(data, paste0(dir, name))
write.table(data, paste0(dir, name), row.names = F)
write.table(data, paste0(dir, name),
row.names = F, quote = F, sep = ",")
dput(data$`Indirizzo email`)
mails= dput(data$`Indirizzo email`)
gsub('"','', mails)
matricole= dput(data$Matricola)
paste(matricole, ",")
paste(matricole, sep= ",")
View(data$Matricola)
View(data)
#test
library("dplyr")
library("ggplot2")
library("Pupilla")
wd= "G:\\Il mio Drive\\pupil NRS\\DotProbeTask\\02 PV\\02 data"
subject= 1:51
#groups
group= c("NS", "S", "NS", "NS", "S","S", "NS", "S",
"S", "S", "S", "S", "S", "S", "NS", "S",
"NS", "S", "NS", "S", "NS", "NS", "S", "NS",
"S", "NS", "NS", "NS", "NS", "NS", "NS", "S",
"S", "S", "S", "NS", "NS", "NS", "NS", "S",
"NS", "NS", "NS", "S", "S", "S", "S", "S",
"S", "S", "S")
data= read_TOBII(subject, wd)
ET= data$ET
BD= data$BD
ET$Event= ifelse(ET$Event== "", NA, ET$Event)
ET= tidyr::fill(ET, Event, .direction = "down")
ET= ET %>%
group_by(p_ID) %>%
mutate(Trial= detect_change(Event, key= "scrambled"))
table(ET$Trial)
table(BD$Trial)
ET= ET[ET$Trial>=0,]
#whether it's practice or experiment
ET$Phase= copy_variable("Phase")
table(ET$Phase, ET$Trial)
#discard practice
ET= ET[ET$Phase== "experiment",]
BD= BD[BD$Phase== "experiment",]
ET$Trial= copy_variable("Trial")
range(ET$Trial)
range(BD$Trial)
ET$Condition= copy_variable("Condition")
ET$Cue= copy_variable("Cue")
ET$Accuracy= copy_variable("Accuracy")
ET$Image= copy_variable("Image")
ET$RT = as.numeric(copy_variable("RT"))
ET$Pupil= consolidate_signal(ET$PupilSizeLeft, ET$PupilSizeRight,
ET$PupilValidityLeft, ET$PupilValidityRight,
strategy = "conservative",
plausible= c(2, 7))
ET$Pupil
ET= ET[ET$Event %in% c("scrambled", "target"),]
ET= ET %>%
group_by(p_ID, Trial) %>%
mutate(Time= c(0,
cumsum(diff(TimeStamp))))
summary(ET$Time)
ET= ET %>%
group_by(p_ID, Trial) %>%
mutate(Anomaly= ifelse(max(Time)>4500, 1, 0))
table(ET$p_ID[ET$Anomaly== 1], ET$Trial[ET$Anomaly== 1]) #for 2 participants, the trial around the break...
ET= ET[ET$Anomaly== 0,]
#realign Time according to start of the target
ET= ET %>%
group_by(p_ID, Trial) %>%
mutate(Time= Time - Time[Event== "target"][1])
summary(ET$Time)
sum(ET$Time >-1000 & ET$Time<3000)/nrow(ET)
ET= ET[ET$Time >-1000 & ET$Time<3000,]
#filter subjs here and add group
ET= ET %>% filter(!p_ID %in% c(2, 9, 10, 13, 25, 29, 30, 34, 38, 48, 49))
# group= group[-c(2, 9, 10, 13, 25, 29, 30, 34, 38,48, 49)]
# table(group)
ET$Group= group[ET$p_ID]
pp_options()
pp_options("spar"= 0.8)
clean_island= function(vector, island_size){
#reshape
grid= embed(vector, island_size+2)
#first and last column must be NA
ss1= is.na(grid[,1]) & is.na(grid[,island_size+2])
#sum of middle columns must NOT be NA
if(island_size==1){
ss2= !is.na(grid[,2])
} else {
mc= 2:(island_size+1)
ss2= !is.na(apply(grid[,mc], 1, sum))
}
#you get the borders
borders= which(ss1 & ss2)
for(i in borders){
vector[(i+1):(i+1+island_size)]= NA
}
return(vector)
}
# x= c(rep(NA, 5), 4, 5, NA, NA)
# clean_island(vector= x,island_size = 2)
# Variable, global to package's namespace.
# This function is not exported to user space and does not need to be documented.
opt= settings::options_manager(
thresh= 3,
speed_method= "z-dynamic",
extend_by= 3,
island_size= 4,
extend_blink= 3,
overall_thresh= 0.4,
consecutive_thresh= NULL,
spar= 0.1
)
# User function that gets exported:
#' Set or get options for Pupilla's preprocessing parameters
#'
#' @param thresh **speed_clean** Threshold (z point or absolute value) above which values are marked as NA.
#' @param speed_method **speed_clean** Whether the 'thresh' is a z-score ('z'), with deviant values
#' omitted once, or until there are no more values above the threshold ('z-dynamic').
#' 'abs' is used instead when a precise absolute value for speed is supplied.
#' @param extend_by **speed_clean** Number of samples starting from the deviant speed values that
#' are stripped (e.g., the signal in proximity of blinks may be biased as well).
#' @param island_size **speed_clean** Islands of signal in the midst of NAs are removed if smaller
#' or equal to this threshold (amount of samples).
#' @param extend_blink **interpolate** NAs are extended by these many samples
#' prior to interpolation. This gets rid of signal that may be compromised
#' in the close proximity of a blink.
#' @param overall_thresh **interpolate** Overall quality threshold: e.g., the total amount of data
#' that is allowed to be missing from the original vector.
#' @param consecutive_thresh **interpolate** Consecutive gaps in the signal: e.g., the total amount of data
#' that is allowed to be missing from the original vector **consecutively**.
#' @param spar **smooth** Smoothing factor as in 'smooth.spline()'.
#' @export
pp_options <- function(...){
# protect against the use of reserved words.
settings::stop_if_reserved(...)
# return/change
opt(...)
}
pp_options("thresh")
pp_options("speed_method")
ET$p_ID
table(ET$p_ID)
vector= ET$Pupil[ET$p_ID== 35 & ET$Trial== 134]
time= ET$Time[ET$p_ID== 35 & ET$Trial== 134]
plot(x= time, y= vector)
thresh= pp_options("thresh")
thresh
speed_method= pp_options("speed_method")
extend_by= pp_options("extend_by")
island_size= pp_options("island_size")
speed_method
extend_by
island_size
space= abs(diff(vector))
speed= space / diff(time)
space= abs(diff(vector))
speed= space / diff(time)
speed
hist(speed)
plot(density(speed))
plot(density(speed, na.rm = T))
quantile(speed, 0.99)
quantile(speed, 0.99, na.rm= T)
quantile(speed, 0.5, na.rm= T)
quantile(speed, 0.95, na.rm= T)
space= abs(diff(vector))
speed= space / diff(time)
#here if speed_method is "z" or "z-dynamic, turn speed to z-scores
if (speed_method %in% c("z", "z-dynamic"){
space= abs(diff(vector))
speed= space / diff(time)
#here if speed_method is "z" or "z-dynamic, turn speed to z-scores
if (speed_method %in% c("z", "z-dynamic")){
speed= (speed - mean(speed, na.rm= T))/sd(speed, na.rm= T)
}
speed_method
speed
if (speed_method %in% c("z", "z-dynamic")){
speed= (speed - mean(speed, na.rm= T))/sd(speed, na.rm= T)
}
speed
indices= abs(speed) > thresh
indices
speed_method
sum(abs(speed) > thresh)
sum(abs(speed) > thresh, na.rm= T)
indices
sum(abs(speed) > thresh, na.rm= T) > 0
indices
speed2= speed
speed2[indices]= NA
length(speed)
length(speed2)
indices= abs(speed) > thresh
speed2= speed
sum(abs(speed) > thresh, na.rm= T) > 0
speed2[indices]= NA
indices
speed2[indices]= NA
speed2= (speed2 - mean(speed2, na.rm= T))/sd(speed2, na.rm= T)
summary(speed2)
indices
indices + (abs(speed2) > thresh)
summary(indices + (abs(speed2) > thresh))
indices= abs(speed) > thresh
speed2= speed
sum(abs(speed2) > thresh, na.rm= T) > 0
while (sum(abs(speed2) > thresh, na.rm= T) > 0){
speed2[indices]= NA
speed2= (speed2 - mean(speed2, na.rm= T))/sd(speed2, na.rm= T)
indices= indices + (abs(speed2) > thresh)
indices= indices>0
}
summary(indices)
speed3= (speed2 - mean(speed2, na.rm= T))/sd(speed2, na.rm= T)
summary(speed3)
indices
indices= abs(speed) > thresh
indices
speed2= speed
indices= abs(speed) > thresh
speed2= speed
while (sum(abs(speed2) > thresh, na.rm= T) > 0){
speed2[indices]= NA
speed2= (speed2 - mean(speed2, na.rm= T))/sd(speed2, na.rm= T)
indices= indices + (abs(speed2) > thresh)
indices= indices>0
print("hi")
}
indices= abs(speed) > thresh
speed2= speed
indices
speed2[indices]= NA
indices= abs(speed) > thresh
speed2= speed
while (sum(abs(speed2) > thresh, na.rm= T) > 0){
speed2[indices]= NA
speed2= (speed2 - mean(speed2, na.rm= T))/sd(speed2, na.rm= T)
indices[(abs(speed2) > thresh)]= TRUE
print(sum(isTRUE(indices)))
}
indices= abs(speed) > thresh
speed2= speed
while (sum(abs(speed2) > thresh, na.rm= T) > 0){
speed2[indices]= NA
speed2= (speed2 - mean(speed2, na.rm= T))/sd(speed2, na.rm= T)
indices[(abs(speed2) > thresh)]= TRUE
print(sum(isTRUE(indices), na.rm= T))
}
indices= abs(speed) > thresh
speed2= speed
sum(abs(speed2) > thresh, na.rm= T) > 0
sum(indices, na.rm= T)
speed2[indices]= NA
speed2= (speed2 - mean(speed2, na.rm= T))/sd(speed2, na.rm= T)
abs(speed2) > thresh
indices[abs(speed2) > thresh]
indices[abs(speed2) > thresh]= TRUE
indices[abs(speed2) > thresh]
print(sum(indices, na.rm= T))
speed2[indices]= NA
speed2= (speed2 - mean(speed2, na.rm= T))/sd(speed2, na.rm= T)
indices[abs(speed2) > thresh]= TRUE
print(sum(indices, na.rm= T))
indices= abs(speed) > thresh
speed2= speed
while (sum(abs(speed2) > thresh, na.rm= T) > 0){
speed2[indices]= NA
speed2= (speed2 - mean(speed2, na.rm= T))/sd(speed2, na.rm= T)
indices[abs(speed2) > thresh]= TRUE
print(sum(indices, na.rm= T))
}
#compute speed
space= abs(diff(vector))
speed= space / diff(time)
#here if speed_method is "z" or "z-dynamic, turn speed to z-scores
if (speed_method %in% c("z", "z-dynamic")){
speed= (speed - mean(speed, na.rm= T))/sd(speed, na.rm= T)
}
# if abs take the absolute value and then check against thresh
#this has not been turned to z scores before
if (speed_method == "abs"){
indices= abs(speed) > thresh
}
# if is "z" take the absolute value and then check against thresh
if (speed_method == "z"){
indices= abs(speed) > thresh
}
#if "z-dynamic repeat until there are no more deviant values
if (speed_method == "z-dynamic"){
indices= abs(speed) > thresh
speed2= speed
while (sum(abs(speed2) > thresh, na.rm= T) > 0){
speed2[indices]= NA
speed2= (speed2 - mean(speed2, na.rm= T))/sd(speed2, na.rm= T)
indices[abs(speed2) > thresh]= TRUE
print(sum(indices, na.rm= T))
}
}
space= diff(vector)
speed= space / diff(time)
#here if speed_method is "z" or "z-dynamic, turn speed to z-scores
if (speed_method %in% c("z", "z-dynamic")){
speed= (speed - mean(speed, na.rm= T))/sd(speed, na.rm= T)
}
# if abs take the absolute value and then check against thresh
#this has not been turned to z scores before
if (speed_method == "abs"){
indices= abs(speed) > thresh
}
# if is "z" take the absolute value and then check against thresh
if (speed_method == "z"){
indices= abs(speed) > thresh
}
#if "z-dynamic repeat until there are no more deviant values
if (speed_method == "z-dynamic"){
indices= abs(speed) > thresh
speed2= speed
while (sum(abs(speed2) > thresh, na.rm= T) > 0){
speed2[indices]= NA
speed2= (speed2 - mean(speed2, na.rm= T))/sd(speed2, na.rm= T)
indices[abs(speed2) > thresh]= TRUE
print(sum(indices, na.rm= T))
}
}
extend_by
#extend if requested
if(!is.null(extend_by)){
#indices= which(speed> thresh) #| is.na(speed)
for(i in indices){
from= i - extend_by
to= i + extend_by
if(from < 1)(from= 1)
if(to>length(speed))(to= length(speed))
speed[from:to]= Inf
}
}
indices
indices
ind2= which(indices= TRUE) #| is.na(speed)
ind2= which(indices== TRUE) #| is.na(speed)
ind2
indices[13:15]
if(!is.null(extend_by)){
ind2= which(indices== TRUE) #| is.na(speed)
for(i in ind2){
from= i - extend_by
to= i + extend_by
if(from < 1)(from= 1)
if(to>length(speed))(to= length(speed))
indices[from:to]= TRUE
}
}
indices[13:15]
clean_island= function(vector, island_size){
#reshape
grid= embed(vector, island_size+2)
#first and last column must be NA
ss1= is.na(grid[,1]) & is.na(grid[,island_size+2])
#sum of middle columns must NOT be NA
if(island_size==1){
ss2= !is.na(grid[,2])
} else {
mc= 2:(island_size+1)
ss2= !is.na(apply(grid[,mc], 1, sum))
}
#you get the borders
borders= which(ss1 & ss2)
for(i in borders){
vector[(i+1):(i+1+island_size)]= NA
}
return(vector)
}
# x= c(rep(NA, 5), 4, 5, NA, NA)
# clean_island(vector= x,island_size = 2)
#' Help identifying artifacts with a speed-based criterion
#'
#' A signal vector is stripped of values exceeding a given
#' threshold, computed on the basis of the absolute speed of signal
#' increase or decrease.
#'
#'
#' @param vector A vector variable to be cleaned
#' @param time A vector variable indicating the elapsed time, needed to compute
#' velocity.
#' @param thresh Threshold (z point or absolute value) above which values are marked as NA.
#' @param speed_method Whether the 'thresh' is a z-score ('z'), with deviant values
#' omitted once, or until there are no more values above the threshold ('z-dynamic').
#' 'abs' is used instead when a precise absolute value for speed is supplied.
#' @param extend_by Number of samples starting from the deviant speed values that
#' are stripped (e.g., the signal in proximity of blinks may be biased as well).
#' @param island_size Islands of signal in the midst of NAs are removed if smaller
#' or equal to this threshold (amount of samples).
#' @return A numeric vector cleaned as requested.
#'
#' @export
speed_clean= function(vector,
time,
thresh= pp_options("thresh"),
speed_method= pp_options("speed_method"),
extend_by= pp_options("extend_by"),
island_size= pp_options("island_size")){
#compute speed
#the absolute value is not taken here anymore
space= diff(vector)
speed= space / diff(time)
#here if speed_method is "z" or "z-dynamic, turn speed to z-scores
if (speed_method %in% c("z", "z-dynamic")){
speed= (speed - mean(speed, na.rm= T))/sd(speed, na.rm= T)
}
# if abs take the absolute value and then check against thresh
#this has not been turned to z scores before
if (speed_method == "abs"){
indices= abs(speed) > thresh
}
# if is "z" take the absolute value and then check against thresh
if (speed_method == "z"){
indices= abs(speed) > thresh
}
#if "z-dynamic repeat until there are no more deviant values
if (speed_method == "z-dynamic"){
indices= abs(speed) > thresh
speed2= speed
while (sum(abs(speed2) > thresh, na.rm= T) > 0){
speed2[indices]= NA
speed2= (speed2 - mean(speed2, na.rm= T))/sd(speed2, na.rm= T)
indices[abs(speed2) > thresh]= TRUE
#print(sum(indices, na.rm= T))
}
}
#extend if requested
if(!is.null(extend_by)){
ind2= which(indices== TRUE) #| is.na(speed)
for(i in ind2){
from= i - extend_by
to= i + extend_by
if(from < 1)(from= 1)
if(to>length(speed))(to= length(speed))
indices[from:to]= TRUE
}
}
#finally set vector to NA where indices is TRUE
vector[c(FALSE, indices)]= NA
#remove islands if requested (and present)
is= 1:island_size
for(i in is) {
vector= clean_island(vector, i)
}
return(vector)
}
devtools::load_all(".")
library(Pupilla)
devtools::load_all(".")
